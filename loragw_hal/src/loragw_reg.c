/*
 / _____)             _              | |    
( (____  _____ ____ _| |_ _____  ____| |__  
 \____ \| ___ |    (_   _) ___ |/ ___)  _ \
 _____) ) ____| | | || |_| ____( (___| | | |
(______/|_____)_|_|_| \__)_____)\____)_| |_|
    ©2013 Semtech-Cycleo

Description:
    Functions used to handle a single Lora gateway.
    Registers are addressed by name.
    Multi-bytes registers are handled automatically.
    Read-modify-write is handled automatically.
*/


/* -------------------------------------------------------------------------- */
/* --- DEPENDANCIES --------------------------------------------------------- */

#include <stdint.h>     /* C99 types */
#include <stdbool.h>    /* bool type */
#include <stdio.h>      /* printf fprintf */

#include "loragw_spi.h"
#include "loragw_reg.h"

/* -------------------------------------------------------------------------- */
/* --- PRIVATE MACROS ------------------------------------------------------- */

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
#ifdef DEBUG
    #define DEBUG_MSG(str)              fprintf(stderr, str)
    #define DEBUG_PRINTF(fmt, args...)  fprintf(stderr,"%s:%d: "fmt, __FUNCTION__, __LINE__, args)
    #define CHECK_NULL(a)               if(a==NULL){fprintf(stderr,"%s:%d: ERROR, NULL POINTER AS ARGUMENT\n", __FUNCTION__, __LINE__);return LGW_REG_ERROR;}
#else
    #define DEBUG_MSG(str)
    #define DEBUG_PRINTF(fmt, args...)
    #define CHECK_NULL(a)               if(a==NULL){return LGW_REG_ERROR;}
#endif

/* -------------------------------------------------------------------------- */
/* --- PRIVATE TYPES -------------------------------------------------------- */

struct lgw_reg_s {
    int8_t      page;       /*!< page containing the register (-1 for all pages) */
    uint8_t     addr;       /*!< base address of the register (7 bit) */
    uint8_t     offs;       /*!< position of the register LSB (between 0 to 7) */
    bool        sign;       /*!< 1 indicates the register is signed (2 complem.) */
    uint8_t     leng;       /*!< number of bits in the register */
    char        name[40];   /*!< name of the register */
    bool        rdon;       /*!< 1 indicates a read-only register */
    int32_t     dflt;       /*!< register default value */
};

/* -------------------------------------------------------------------------- */
/* --- PRIVATE CONSTANTS ---------------------------------------------------- */

#define PAGE_ADDR       0x00    
#define PAGE_MASK       0x03

/*
auto generated register mapping for C code : 10-Jun-2013 16:22:30
this file contains autogenerated C struct used to access the LORA register from the Primer firmware
this file is autogenerated from registers description
227 registers are defined
*/
const struct lgw_reg_s loregs[LGW_TOTALREGS] = {
    {-1,0,0,0,2,"PAGE_REG",0,0},
    {-1,0,7,0,1,"SOFT_RESET",0,0},
    {-1,1,0,0,8,"VERSION",1,100},
    {-1,2,0,0,16,"RX_DATA_BUF_ADDR",0,0},
    {-1,4,0,0,8,"RX_DATA_BUF_DATA",1,0},
    {-1,5,0,0,8,"TX_DATA_BUF_ADDR",0,0},
    {-1,6,0,0,8,"TX_DATA_BUF_DATA",0,0},
    {-1,7,0,0,8,"CAPTURE_RAM_ADDR",0,0},
    {-1,8,0,0,8,"CAPTURE_RAM_DATA",1,0},
    {-1,9,0,0,8,"PIC_PROM_ADDR",0,0},
    {-1,10,0,0,8,"PIC_PROM_DATA",0,0},
    {-1,11,0,0,8,"RX_PACKET_DATA_FIFO_NUM_STORED",0,0},
    {-1,12,0,0,16,"RX_PACKET_DATA_FIFO_ADDR_POINTER",1,0},
    {-1,14,0,0,8,"RX_PACKET_DATA_FIFO_STATUS",1,0},
    {-1,15,0,0,8,"RX_PACKET_DATA_FIFO_PAYLOAD_SIZE",1,0},
    {-1,16,0,0,1,"MBWSSF_MODEM_ENABLE",0,0},
    {-1,16,1,0,1,"CONCENTRATOR_MODEM_ENABLE",0,0},
    {-1,16,2,0,1,"FSK_MODEM_ENABLE",0,0},
    {-1,17,0,0,1,"CLK32M_EN",0,1},
    {-1,17,1,0,1,"CLKHS_EN",0,1},
    {0,18,0,0,1,"RX_INVERT_IQ",0,0},
    {0,18,1,0,1,"MODEM_INVERT_IQ",0,1},
    {0,18,2,0,1,"MBWSSF_MODEM_INVERT_IQ",0,0},
    {0,18,3,0,1,"RX_EDGE_SELECT",0,0},
    {0,18,4,0,1,"MISC_RADIO_EN",0,0},
    {0,19,0,0,4,"FILTER_GAIN",0,7},
    {0,20,0,0,8,"RADIO_SELECT",0,240},
    {0,21,0,1,13,"IF_FREQ_0",0,-384},
    {0,23,0,1,13,"IF_FREQ_1",0,-128},
    {0,25,0,1,13,"IF_FREQ_2",0,128},
    {0,27,0,1,13,"IF_FREQ_3",0,384},
    {0,29,0,1,13,"IF_FREQ_4",0,-384},
    {0,31,0,1,13,"IF_FREQ_5",0,-128},
    {0,33,0,1,13,"IF_FREQ_6",0,128},
    {0,35,0,1,13,"IF_FREQ_7",0,384},
    {0,37,0,1,13,"IF_FREQ_8",0,0},
    {0,39,0,1,13,"IF_FREQ_9",0,0},
    {0,41,0,0,8,"CORR0_CHAN",0,0},
    {0,42,0,0,8,"CORR1_CHAN",0,1},
    {0,43,0,0,8,"CORR2_CHAN",0,2},
    {0,44,0,0,8,"CORR3_CHAN",0,3},
    {0,45,0,0,8,"CORR4_CHAN",0,4},
    {0,46,0,0,8,"CORR5_CHAN",0,5},
    {0,47,0,0,8,"CORR6_CHAN",0,6},
    {0,48,0,0,8,"CORR7_CHAN",0,7},
    {0,49,0,0,1,"CHANN_OVERRIDE_AGC_GAIN",0,0},
    {0,49,1,0,4,"CHANN_AGC_GAIN",0,7},
    {0,50,0,0,7,"CORR_DETECT_EN",0,126},
    {0,51,0,0,1,"CORR_SAME_PEAKS_OPTION_SF6",0,0},
    {0,51,1,0,1,"CORR_SAME_PEAKS_OPTION_SF7",0,1},
    {0,51,2,0,1,"CORR_SAME_PEAKS_OPTION_SF8",0,1},
    {0,51,3,0,1,"CORR_SAME_PEAKS_OPTION_SF9",0,1},
    {0,51,4,0,1,"CORR_SAME_PEAKS_OPTION_SF10",0,1},
    {0,51,5,0,1,"CORR_SAME_PEAKS_OPTION_SF11",0,1},
    {0,51,6,0,1,"CORR_SAME_PEAKS_OPTION_SF12",0,1},
    {0,52,0,0,4,"CORR_SIG_NOISE_RATIO_SF6",0,4},
    {0,52,4,0,4,"CORR_SIG_NOISE_RATIO_SF7",0,4},
    {0,53,0,0,4,"CORR_SIG_NOISE_RATIO_SF8",0,4},
    {0,53,4,0,4,"CORR_SIG_NOISE_RATIO_SF9",0,4},
    {0,54,0,0,4,"CORR_SIG_NOISE_RATIO_SF10",0,4},
    {0,54,4,0,4,"CORR_SIG_NOISE_RATIO_SF11",0,4},
    {0,55,0,0,4,"CORR_SIG_NOISE_RATIO_SF12",0,4},
    {0,56,0,0,4,"CORR_NUM_SAME_PEAK",0,4},
    {0,56,4,0,3,"CORR_MAC_GAIN",0,5},
    {0,57,0,0,12,"ADJUST_MODEM_START_OFFSET_RDX8",0,0},
    {0,59,0,0,12,"ADJUST_MODEM_START_OFFSET_RDX4",0,0},
    {0,61,0,0,12,"ADJUST_MODEM_START_OFFSET_SF12_RDX4",0,4092},
    {0,63,0,0,8,"DBG_CORR_SELECT_SF",0,7},
    {0,64,0,0,8,"DBG_CORR_SELECT_CHANNEL",0,0},
    {0,65,0,0,8,"DBG_DETECT_CPT",1,0},
    {0,66,0,0,8,"DBG_SYMB_CPT",1,0},
    {0,67,0,0,1,"CHIRP_INVERT_RX",0,1},
    {0,67,1,0,1,"DC_NOTCH_EN",0,0},
    {0,68,0,0,1,"IMPLICIT_CRC_EN",0,0},
    {0,68,1,0,3,"IMPLICIT_CODING_RATE",0,0},
    {0,69,0,0,8,"IMPLICIT_PAYLOAD_LENGHT",0,0},
    {0,70,0,0,8,"FREQ_TO_TIME_INVERT",0,29},
    {0,71,0,0,6,"FREQ_TO_TIME_DRIFT",0,9},
    {0,72,0,0,2,"PAYLOAD_FINE_TIMING_GAIN",0,2},
    {0,72,2,0,2,"PREAMBLE_FINE_TIMING_GAIN",0,1},
    {0,72,4,0,2,"TRACKING_INTEGRAL",0,0},
    {0,73,0,0,4,"FRAME_SYNCH_PEAK1_POS",0,1},
    {0,73,4,0,4,"FRAME_SYNCH_PEAK2_POS",0,2},
    {0,74,0,0,16,"PREAMBLE_SYMB1_NB",0,10},
    {0,76,0,0,1,"FRAME_SYNCH_GAIN",0,1},
    {0,76,1,0,1,"SYNCH_DETECT_TH",0,1},
    {0,77,0,0,4,"LLR_SCALE",0,8},
    {0,77,4,0,2,"SNR_AVG_CST",0,2},
    {0,78,0,0,7,"PPM_OFFSET",0,0},
    {0,79,0,0,8,"MAX_PAYLOAD_LEN",0,255},
    {0,80,0,0,1,"ONLY_CRC_EN",0,1},
    {0,81,0,0,8,"ZERO_PAD",0,0},
    {0,82,0,0,1,"MBWSSF_IMPLICIT_HEADER",0,0},
    {0,82,1,0,1,"MBWSSF_IMPLICIT_CRC_EN",0,0},
    {0,82,2,0,3,"MBWSSF_IMPLICIT_CODING_RATE",0,0},
    {0,83,0,0,8,"MBWSSF_IMPLICIT_PAYLOAD_LENGHT",0,0},
    {0,84,0,0,1,"MBWSSF_AGC_FREEZE_ON_DETECT",0,1},
    {0,85,0,0,4,"MBWSSF_FRAME_SYNCH_PEAK1_POS",0,1},
    {0,85,4,0,4,"MBWSSF_FRAME_SYNCH_PEAK2_POS",0,2},
    {0,86,0,0,16,"MBWSSF_PREAMBLE_SYMB1_NB",0,10},
    {0,88,0,0,1,"MBWSSF_FRAME_SYNCH_GAIN",0,1},
    {0,88,1,0,1,"MBWSSF_SYNCH_DETECT_TH",0,1},
    {0,89,0,0,8,"MBWSSF_DETECT_MIN_SINGLE_PEAK",0,10},
    {0,90,0,0,3,"MBWSSF_DETECT_TRIG_SAME_PEAK_NB",0,3},
    {0,91,0,0,8,"MBWSSF_FREQ_TO_TIME_INVERT",0,29},
    {0,92,0,0,6,"MBWSSF_FREQ_TO_TIME_DRIFT",0,36},
    {0,93,0,0,12,"MBWSSF_PPM_CORRECTION",0,0},
    {0,95,0,0,2,"MBWSSF_PAYLOAD_FINE_TIMING_GAIN",0,2},
    {0,95,2,0,2,"MBWSSF_PREAMBLE_FINE_TIMING_GAIN",0,1},
    {0,95,4,0,2,"MBWSSF_TRACKING_INTEGRAL",0,0},
    {0,96,0,0,8,"MBWSSF_ZERO_PAD",0,0},
    {0,97,0,0,2,"MBWSSF_MODEM_BW",0,0},
    {0,97,2,0,1,"MBWSSF_RADIO_SELECT",0,0},
    {0,97,3,0,1,"MBWSSF_RX_CHIRP_INVERT",0,1},
    {0,98,0,0,4,"MBWSSF_LLR_SCALE",0,8},
    {0,98,4,0,2,"MBWSSF_SNR_AVG_CST",0,3},
    {0,98,6,0,1,"MBWSSF_PPM_OFFSET",0,0},
    {0,99,0,0,4,"MBWSSF_RATE_SF",0,7},
    {0,99,4,0,1,"MBWSSF_ONLY_CRC_EN",0,1},
    {0,100,0,0,8,"MBWSSF_MAX_PAYLOAD_LEN",0,255},
    {0,101,0,0,4,"DEC_GAIN_OFFSET",0,8},
    {0,102,0,0,1,"FORCE_HOST_CONFIG_CTRL",0,1},
    {0,102,1,0,1,"FORCE_HOST_SPI_MASTER_CTRL",0,1},
    {0,102,2,0,1,"FORCE_CHAN_GAIN",0,1},
    {0,102,3,0,1,"FORCE_DEC_FILTER_GAIN",0,1},
    {0,102,4,0,1,"FORCE_HOST_RADIO_CTRL",0,1},
    {0,103,0,0,2,"PIC16F84_RST",0,3},
    {0,103,2,0,2,"PIC16F84_SELECT_MUX",0,0},
    {0,103,4,0,2,"PIC16F84_CORRUPTION_DETECTED",1,0},
    {0,104,0,0,8,"CHANN_SELECT_RSSI",0,1},
    {0,105,0,0,8,"RSSI_BB_DEFAULT_VALUE",0,32},
    {0,106,0,0,8,"RSSI_DEC_DEFAULT_VALUE",0,100},
    {0,107,0,0,8,"RSSI_CHANN_DEFAULT_VALUE",0,100},
    {0,108,0,0,5,"RSSI_BB_FILTER_ALPHA",0,7},
    {0,109,0,0,5,"RSSI_DEC_FILTER_ALPHA",0,5},
    {0,110,0,0,5,"RSSI_CHANN_FILTER_ALPHA",0,8},
    {0,111,0,0,6,"IQ_MISMATCH_A_AMP_COEFF",0,0},
    {0,112,0,0,6,"IQ_MISMATCH_A_PHI_COEFF",0,0},
    {0,113,0,0,6,"IQ_MISMATCH_B_AMP_COEFF",0,0},
    {0,113,6,0,1,"IQ_MISMATCH_B_SEL_I",0,0},
    {0,114,0,0,6,"IQ_MISMATCH_B_PHI_COEFF",0,0},
    {1,18,0,0,1,"TX_TRIG_IMMEDIATE",0,0},
    {1,18,1,0,1,"TX_TRIG_DELAYED",0,0},
    {1,19,0,0,4,"TX_FRAME_SYNCH_PEAK1_POS",0,1},
    {1,19,4,0,4,"TX_FRAME_SYNCH_PEAK2_POS",0,2},
    {1,20,0,0,16,"TX_PREAMBLE_SYMB1_NB",0,10},
    {1,22,0,0,8,"TX_OFFSET_I",0,0},
    {1,23,0,0,8,"TX_OFFSET_Q",0,0},
    {1,24,0,0,1,"TX_MODE",0,0},
    {1,24,1,0,4,"TX_ZERO_PAD",0,0},
    {1,24,5,0,1,"TX_PPM_OFFSET",0,0},
    {1,24,6,0,1,"TX_CHIRP_INVERT",0,0},
    {1,24,7,0,1,"TX_CONT_CHIRP",0,0},
    {1,25,0,0,2,"TX_GAIN",0,0},
    {1,25,2,0,3,"TX_CHIRP_LOW_PASS",0,0},
    {1,25,5,0,2,"TX_FCC_WIDEBAND",0,0},
    {1,25,7,0,1,"TX_SWAP_IQ",0,0},
    {2,18,0,0,8,"SPI_RADIO_A__DATA",0,0},
    {2,19,0,0,8,"SPI_RADIO_A__DATA_READBACK",1,0},
    {2,20,0,0,14,"SPI_RADIO_A__ADDR",0,0},
    {2,22,0,0,1,"SPI_RADIO_A__CS",0,0},
    {2,23,0,0,1,"RADIO_EN_A",0,0},
    {2,23,1,0,1,"RADIO_RST_A",0,0},
    {2,23,2,0,1,"LNA_EN_A",0,0},
    {2,23,3,0,1,"PA_EN_A",0,0},
    {2,23,4,0,2,"PA_GAIN_A",0,0},
    {2,24,0,0,8,"SPI_RADIO_B__DATA",0,0},
    {2,25,0,0,8,"SPI_RADIO_B__DATA_READBACK",1,0},
    {2,26,0,0,14,"SPI_RADIO_B__ADDR",0,0},
    {2,28,0,0,1,"SPI_RADIO_B__CS",0,0},
    {2,29,0,0,1,"RADIO_EN_B",0,0},
    {2,29,1,0,1,"RADIO_RST_B",0,0},
    {2,29,2,0,1,"LNA_EN_B",0,0},
    {2,29,3,0,1,"PA_EN_B",0,0},
    {2,29,4,0,2,"PA_GAIN_B",0,0},
    {2,30,0,0,5,"CAPTURE_SOURCE",0,0},
    {2,30,5,0,1,"CAPTURE_START",0,0},
    {2,30,6,0,1,"CAPTURE_FORCE_TRIGGER",0,0},
    {2,30,7,0,1,"CAPTURE_WRAP",0,0},
    {2,31,0,0,16,"CAPTURE_PERIOD",0,0},
    {2,33,0,0,3,"LED_REG",0,3},
    {2,34,0,0,8,"MODEM_STATUS",1,0},
    {2,35,0,0,8,"VALID_HEADER_COUNTER_0",1,0},
    {2,36,0,0,8,"VALID_HEADER_COUNTER_1",1,0},
    {2,37,0,0,8,"VALID_PACKET_COUNTER_0",1,0},
    {2,38,0,0,8,"VALID_PACKET_COUNTER_1",1,0},
    {2,39,0,0,8,"VALID_HEADER_COUNTER_MBWSSF",1,0},
    {2,40,0,0,8,"VALID_HEADER_COUNTER_FSK",1,0},
    {2,41,0,0,8,"VALID_PACKET_COUNTER_MBWSSF",1,0},
    {2,42,0,0,8,"VALID_PACKET_COUNTER_FSK",1,0},
    {2,43,0,0,8,"CHANN_RSSI",1,0},
    {2,44,0,0,8,"BB_RSSI",1,0},
    {2,45,0,0,8,"DEC_RSSI",1,0},
    {2,46,0,0,8,"DBG_PIC_DATA",1,0},
    {2,47,0,0,8,"DBG_ARB_PIC_RAM_DATA",1,0},
    {2,48,0,0,8,"DBG_AGC_PIC_RAM_DATA",1,0},
    {2,49,0,0,16,"NEXT_PACKET_CNT",1,0},
    {2,51,0,0,16,"ADDR_CAPTURE_COUNT",1,0},
    {2,53,0,0,32,"TIMESTAMP",1,0},
    {2,57,0,0,4,"DBG_CHANN0_GAIN",1,0},
    {2,57,4,0,4,"DBG_CHANN1_GAIN",1,0},
    {2,58,0,0,4,"DBG_CHANN2_GAIN",1,0},
    {2,58,4,0,4,"DBG_CHANN3_GAIN",1,0},
    {2,59,0,0,4,"DBG_CHANN4_GAIN",1,0},
    {2,59,4,0,4,"DBG_CHANN5_GAIN",1,0},
    {2,60,0,0,4,"DBG_CHANN6_GAIN",1,0},
    {2,60,4,0,4,"DBG_CHANN7_GAIN",1,0},
    {2,61,0,0,4,"DBG_DEC_FILT_GAIN",1,0},
    {2,62,0,0,3,"SPI_DATA_FIFO_PTR",1,0},
    {2,62,3,0,3,"PACKET_DATA_FIFO_PTR",1,0},
    {2,63,0,0,8,"DBG_ARB_PIC_RAM_ADDR",0,0},
    {2,64,0,0,8,"DBG_AGC_PIC_RAM_ADDR",0,0},
    {2,65,0,0,1,"SPI_MASTER_CHIP_SELECT_POLARITY",0,0},
    {2,65,1,0,1,"SPI_MASTER_CPOL",0,0},
    {2,65,2,0,1,"SPI_MASTER_CPHA",0,0},
    {2,66,0,0,1,"SIG_GEN_ANALYSER_MUX_SEL",0,0},
    {2,67,0,0,1,"SIG_GEN_EN",0,0},
    {2,67,1,0,1,"SIG_ANALYSER_EN",0,0},
    {2,67,2,0,2,"SIG_ANALYSER_AVG_LEN",0,0},
    {2,67,4,0,3,"SIG_ANALYSER_PRECISION",0,0},
    {2,67,7,0,1,"SIG_ANALYSER_VALID_OUT",1,0},
    {2,68,0,0,8,"SIG_GEN_FREQ",0,0},
    {2,69,0,0,8,"SIG_ANALYSER_FREQ",0,0},
    {2,70,0,0,8,"SIG_ANALYSER_I_OUT",1,0},
    {2,71,0,0,8,"SIG_ANALYSER_Q_OUT",1,0},
    {2,72,0,0,1,"GPS_EN",0,0},
    {2,72,1,0,1,"GPS_POL",0,1}
};

/* -------------------------------------------------------------------------- */
/* --- PRIVATE VARIABLES ---------------------------------------------------- */

static int lgw_spidesc = -1; /*! file descriptor to the SPI device */
static int lgw_regpage = -1; /*! keep the value of the register page selected */

/* -------------------------------------------------------------------------- */
/* --- PRIVATE FUNCTIONS ---------------------------------------------------- */

int page_switch(uint8_t target) {
    lgw_regpage = PAGE_MASK & target;
    lgw_spi_w(lgw_spidesc, PAGE_ADDR, (uint8_t)lgw_regpage);
    return LGW_REG_SUCCESS;
}

/* -------------------------------------------------------------------------- */
/* --- PUBLIC FUNCTIONS DEFINITION ------------------------------------------ */

/* Gateway connect */
int lgw_connect(void) {
    int spi_stat = LGW_SPI_SUCCESS;
    uint8_t u = 0;
    
    if (lgw_spidesc >= 0) {
        DEBUG_MSG("WARNING: GATEWAY WAS ALREADY CONNECTED\n");
        lgw_spi_close(lgw_spidesc);
    }
    /* open the SPI link */
    spi_stat = lgw_spi_open(&lgw_spidesc);
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR CONNECTING GATEWAY\n");
        return LGW_REG_ERROR;
    }
    /* write 0 to the page/reset register */
    spi_stat = lgw_spi_w(lgw_spidesc, loregs[LGW_PAGE_REG].addr, 0);
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR WRITING PAGE REGISTER\n");
        return LGW_REG_ERROR;
    } else {
        lgw_regpage = 0;
    }
    /* checking the version register */
    spi_stat = lgw_spi_r(lgw_spidesc, loregs[LGW_VERSION].addr, &u);
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR READING VERSION REGISTER\n");
        return LGW_REG_ERROR;
    } else if (u == 0) {
        DEBUG_MSG("ERROR, GATEWAY SEEMS DISCONNECTED\n");
        return LGW_REG_ERROR;
    } else if (u != loregs[LGW_VERSION].dflt) {
        DEBUG_MSG("ERROR, MISMATCH BETWEEN EXPECTED REG VERSION AND READ REG VERSION\n");
        return LGW_REG_ERROR;
    }
    DEBUG_MSG("SUCCESS CONNECTING THE GATEWAY\n");
    return LGW_REG_SUCCESS;
}

/* Gateway disconnect */
int lgw_disconnect(void) {
    if (lgw_spidesc >= 0) {
        lgw_spi_close(lgw_spidesc);
        lgw_spidesc = -1;
        DEBUG_MSG("SUCCESS DISCONNECTING THE GATEWAY\n");
        return LGW_REG_SUCCESS;
    } else {
        DEBUG_MSG("WARNING, GATEWAY WAS ALREADY DISCONNECTED\n");
        lgw_spidesc = -1;
        return LGW_REG_ERROR;
    }
}

/* soft-reset function */
int lgw_soft_reset(void) {
    int32_t read_value;
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR, GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    lgw_spi_w(lgw_spidesc, 0, 0x80); /* 1 -> SOFT_RESET bit */
    lgw_regpage = 0; /* reset the paging static variable */
    return LGW_REG_SUCCESS;
}

/* register verification */
int lgw_reg_check(FILE *f) {
    struct lgw_reg_s r;
    int32_t read_value;
    char ok_msg[] = "+++MATCH+++";
    char notok_msg[] = "###MISMATCH###";
    char *ptr;
    int i;
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR, GATEWAY UNCONNECTED\n");
        fprintf(f, "ERROR, GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    fprintf(f, "Start of register verification\n");
    for (i=0; i<LGW_TOTALREGS; ++i) {
        r = loregs[i];
        lgw_reg_r(i, &read_value);
        ptr = (read_value == r.dflt) ? ok_msg : notok_msg;
        if (r.sign == true)
            fprintf(f, "%s reg: %s read: %d (%x) default: %d (%x)\n", ptr, r.name, read_value, read_value, r.dflt, r.dflt);
        else
            fprintf(f, "%s reg: %s read: %u (%x) default: %u (%x)\n", ptr, r.name, read_value, read_value, r.dflt, r.dflt);
    }
    fprintf(f, "End of register verification\n");
    
    return LGW_REG_SUCCESS;
}

/* Write to a register addressed by name */
int lgw_reg_w(uint16_t register_id, int32_t reg_value) {
    int spi_stat = LGW_SPI_SUCCESS;
    struct lgw_reg_s r;
    uint8_t buf[4] = "\x00\x00\x00\x00";
    int i, size_byte;
    
    /* check input parameters */
    if (register_id >= LGW_TOTALREGS) {
        DEBUG_MSG("ERROR, REGISTER NUMBER OUT OF DEFINED RANGE\n");
        return LGW_REG_ERROR;
    }
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR, GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    /* intercept direct access to PAGE_REG & SOFT_RESET */
    if (register_id == LGW_PAGE_REG) {
        page_switch(reg_value);
        return LGW_REG_SUCCESS;
    } else if (register_id == LGW_SOFT_RESET) {
        /* only reset if lsb is 1 */
        if (reg_value%2 != 0)
            lgw_soft_reset();
        return LGW_REG_SUCCESS;
    }
    
    /* get register struct from the struct array */
    r = loregs[register_id];
    
    /* reject write to read-only registers */
    if (r.rdon == 1){
        DEBUG_MSG("ERROR, TRYING TO WRITE A READ-ONLY REGISTER\n");
        return LGW_REG_ERROR;
    }
    
    /* select proper register page if needed */
    if ((r.page != -1) && (r.page != lgw_regpage)) {
        spi_stat += page_switch(r.page);
    }
    
    if ((r.leng == 8) && (r.offs == 0)) {
        /* direct write */
        spi_stat += lgw_spi_w(lgw_spidesc, r.addr, (uint8_t)reg_value);
    } else if ((r.offs + r.leng) <= 8) {
        /* single-byte read-modify-write, offs:[0-7], leng:[1-7] */
        spi_stat += lgw_spi_r(lgw_spidesc, r.addr, &buf[0]);
        buf[1] = ((1 << r.leng) - 1) << r.offs; /* bit mask */
        buf[2] = ((uint8_t)reg_value) << r.offs; /* new data offsetted */
        buf[3] = (~buf[1] & buf[0]) | (buf[1] & buf[2]); /* mixing old & new data */
        spi_stat += lgw_spi_w(lgw_spidesc, r.addr, buf[3]);
    } else if ((r.offs == 0) && (r.leng > 0) && (r.leng <= 32)) {
        /* multi-byte direct write routine */
        size_byte = (r.leng + 7) / 8; /* add a byte if it's not an exact multiple of 8 */ 
        for (i=0; i<size_byte; ++i) {
            /* big endian register file for a file on N bytes
            Least significant byte is stored in buf[0], most one in buf[N-1] */
            buf[i] = (uint8_t)(0x000000FF & reg_value);
            reg_value = (reg_value >> 8);
        }
        spi_stat += lgw_spi_wb(lgw_spidesc, r.addr, buf, size_byte); /* write the register in one burst */
    } else {
        /* register spanning multiple memory bytes but with an offset */
        DEBUG_MSG("ERROR, REGISTER SIZE AND OFFSET ARE NOT SUPPORTED\n");
        return LGW_REG_ERROR;
    }
    
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("SPI ERROR DURING REGISTER WRITE\n");
        return LGW_REG_ERROR;
    } else {
        return LGW_REG_SUCCESS;
    }
}

/* Read to a register addressed by name */
int lgw_reg_r(uint16_t register_id, int32_t *reg_value) {
    int spi_stat = LGW_SPI_SUCCESS;
    struct lgw_reg_s r;
    uint8_t bufu[4] = "\x00\x00\x00\x00";
    int8_t *bufs = bufu;
    int i, size_byte;
    uint32_t u = 0;
    
    /* check input parameters */
    CHECK_NULL(reg_value);
    if (register_id >= LGW_TOTALREGS) {
        DEBUG_MSG("ERROR, REGISTER NUMBER OUT OF DEFINED RANGE\n");
        return LGW_REG_ERROR;
    }
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR, GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    /* get register struct from the struct array */
    r = loregs[register_id];
    
    /* select proper register page if needed */
    if ((r.page != -1) && (r.page != lgw_regpage)) {
        spi_stat += page_switch(r.page);
    }
    
    if ((r.offs + r.leng) <= 8) {
        /* read one byte, then shift and mask bits to get reg value with sign extension if needed */
        spi_stat += lgw_spi_r(lgw_spidesc, r.addr, &bufu[0]);
        bufu[1] = bufu[0] << (8 - r.leng - r.offs); /* left-align the data */
        if (r.sign == true) {
            bufs[2] = bufs[1] >> (8 - r.leng); /* right align the data with sign extension */
            *reg_value = (int32_t)bufs[2]; /* signed pointer -> 32b sign extension */
        } else {
            bufu[2] = bufu[1] >> (8 - r.leng); /* right align the data, no sign extension */
            *reg_value = (int32_t)bufu[2]; /* unsigned pointer -> no sign extension */
        }
    } else if ((r.offs == 0) && (r.leng > 0) && (r.leng <= 32)) {
        size_byte = (r.leng + 7) / 8; /* add a byte if it's not an exact multiple of 8 */ 
        spi_stat += lgw_spi_rb(lgw_spidesc, r.addr, bufu, size_byte);
        u = 0;
        for (i=(size_byte-1); i>=0; --i) {
            u = (uint32_t)bufu[i] + (u << 8); /* transform a 4-byte array into a 32 bit word */
        }
        if (r.sign == true) {
            u = u << (32 - r.leng); /* left-align the data */
            *reg_value = (int32_t)u >> (32 - r.leng); /* right-align the data with sign extension */
        } else {
            *reg_value = (int32_t)u; /* unsigned value -> return 'as is' */
        }
    } else {
        /* register spanning multiple memory bytes but with an offset */
        DEBUG_MSG("ERROR, REGISTER SIZE AND OFFSET ARE NOT SUPPORTED\n");
        return LGW_REG_ERROR;
    }
    
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("SPI ERROR DURING REGISTER WRITE\n");
        return LGW_REG_ERROR;
    } else {
        return LGW_REG_SUCCESS;
    }
}

/* Point to a register by name and do a burst write */
int lgw_reg_wb(uint16_t register_id, uint8_t *data, uint16_t size) {
    int spi_stat;
    struct lgw_reg_s r;
    
    /* check input parameters */
    CHECK_NULL(data);
    if (size == 0) {
        DEBUG_MSG("ERROR, BURST OF NULL LENGTH\n");
        return LGW_REG_ERROR;
    }
    if (register_id >= LGW_TOTALREGS) {
        DEBUG_MSG("ERROR, REGISTER NUMBER OUT OF DEFINED RANGE\n");
        return LGW_REG_ERROR;
    }
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR, GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    /* get register struct from the struct array */
    r = loregs[register_id];
    
    /* reject write to read-only registers */
    if (r.rdon == 1){
        DEBUG_MSG("ERROR, TRYING TO BURST WRITE A READ-ONLY REGISTER\n");
        return LGW_REG_ERROR;
    }
    
    /* select proper register page if needed */
    if ((r.page != -1) && (r.page != lgw_regpage)) {
        spi_stat += page_switch(r.page);
    }
    
    /* do the burst write */
    spi_stat = lgw_spi_wb(lgw_spidesc, r.addr, data, size);
    
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("SPI ERROR DURING REGISTER BURST WRITE\n");
        return LGW_REG_ERROR;
    } else {
        return LGW_REG_SUCCESS;
    }
}

/* Point to a register by name and do a burst read */
int lgw_reg_rb(uint16_t register_id, uint8_t *data, uint16_t size) {
    int spi_stat;
    struct lgw_reg_s r;
    
    /* check input parameters */
    CHECK_NULL(data);
    if (size == 0) {
        DEBUG_MSG("ERROR, BURST OF NULL LENGTH\n");
        return LGW_REG_ERROR;
    }
    if (register_id >= LGW_TOTALREGS) {
        DEBUG_MSG("ERROR, REGISTER NUMBER OUT OF DEFINED RANGE\n");
        return LGW_REG_ERROR;
    }
    
    /* check if SPI is initialised */
    if ((lgw_spidesc < 0) || (lgw_regpage < 0)) {
        DEBUG_MSG("ERROR, GATEWAY UNCONNECTED\n");
        return LGW_REG_ERROR;
    }
    
    /* get register struct from the struct array */
    r = loregs[register_id];
    
    /* select proper register page if needed */
    if ((r.page != -1) && (r.page != lgw_regpage)) {
        spi_stat += page_switch(r.page);
    }
    
    /* do the burst read */
    spi_stat = lgw_spi_rb(lgw_spidesc, r.addr, data, size);
    
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("SPI ERROR DURING REGISTER BURST READ\n");
        return LGW_REG_ERROR;
    } else {
        return LGW_REG_SUCCESS;
    }
}

/* --- EOF ------------------------------------------------------------------ */
